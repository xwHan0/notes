<html>
<head>
<meta charset="UTF-8">
</head>
<body>

<h1>Background</h1>
<p>OOP以数据为设计核心，所有的处理（OOP称之为方法）都绑定到了数据类型中。若需要为当前类型增加新的处理，按照OOP的设计，应该扩展一个子类，在子类中添加新的方法，然后在原使用父类的地方都使用子类来替代。</p>
<p>这种扩展的问题在于：</p>
<ul>
  <li>现有的代码可能都是基于父类来定义的。所以每次需要使用新方法时，一般是先转换父类实例到子类，然后调用方法，最后再依据情况看是否还需要转回去。处理起来比较啰嗦。</li>
  <li></li>
</ul>
<p>隐式类型转换就是依靠编译器来实现从使用者角度看的自动的类型转换。本质上，这种转换不仅用于父类转子类，它可以用于所有需要类型转换的地方。</p>

<h1>Usage</h1>
<h2>Syntax<h2>
<pre>
implicit def translate-func: new-type (obj: old-type);
</pre>
<h2>Process</h2>
<p>当在使用new-type数据的地方没有找到new-type类型，则编译器开始查找是否有定义为输出new-type并且输入为old-type的隐式类型转换函数。若有则执行该转换。（若查到多个则上报中断）</p>
<p>隐式转化对于OOP这种多类型语言非常方便。考虑到转化的安全，隐式转化有以下约束：</p>
<ul>
<li>隐式转化只能直接</li>
</ul>

</body>
</html>